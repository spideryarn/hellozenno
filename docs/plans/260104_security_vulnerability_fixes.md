# Plan: Security Vulnerability Fixes

**Date:** 2026-01-04
**Status:** Draft

## Overview

Fix security vulnerabilities identified by GitHub code scanning and security audit. This plan addresses open redirect, DOM XSS, stack trace exposure, SSRF, and GitHub Actions permission issues across the HelloZenno codebase.

## Context

### Relevant Findings
- GitHub code scanning alerts active for multiple vulnerability types
- Dependabot alerts triggered by dependencies in `backend/old_frontend/` directory
- Security audit JSON files available: `security-audit-before.json`, `security-audit-after.json`

### Key Constraints
- Changes must not break existing authentication flows
- Error messages in production must not expose internal details
- SSRF protection must not block legitimate external URLs

### Success Criteria
- All GitHub code scanning alerts addressed
- No regressions in backend tests (`pytest backend/tests/`)
- Frontend type check passes (`cd frontend && npm run check`)
- Application loads and basic navigation works
- Dependabot alerts for old_frontend disappear after deletion

## Stages

### Stage 1: Quick Wins - Low Risk, High Value
**Goal:** Fix the simplest, lowest-risk vulnerabilities that provide immediate security value
**Estimated Time:** ~30 minutes

**Files to Modify:**
- `backend/utils/auth_utils.py`
- `backend/static/js/sourcefile.js`
- `backend/static/js/sourcefiles.js`
- `.github/workflows/security-audit.yml`

**Steps:**

#### 1.1 Open Redirect Fix (`backend/utils/auth_utils.py:249`)
1. Add a new function `is_safe_redirect_url(url: str) -> bool`:
   ```python
   def is_safe_redirect_url(url: str) -> bool:
       """
       Validate that a redirect URL is safe (relative path only).
       Prevents open redirect attacks by blocking absolute URLs with schemes.
       """
       if not url:
           return False
       from urllib.parse import urlparse
       parsed = urlparse(url)
       # Only allow relative URLs (no scheme, no netloc)
       # Must start with / to be a valid path
       return (
           not parsed.scheme and 
           not parsed.netloc and 
           url.startswith('/')
       )
   ```
2. Update the redirect handling code at line 249 to use validation:
   ```python
   redirect_url = request.args.get('redirect', '/')
   if not is_safe_redirect_url(redirect_url):
       redirect_url = '/'
   ```

#### 1.2 DOM XSS Fix (`backend/static/js/sourcefile.js:99`)
1. Locate the `innerHTML` assignment
2. Change to `textContent` for plain text content
3. If HTML structure is needed, use DOM methods:
   ```javascript
   // Before: element.innerHTML = userContent;
   // After: element.textContent = userContent;
   ```

#### 1.3 DOM XSS Fix (`backend/static/js/sourcefiles.js:457`)
1. Locate the template string with innerHTML
2. Replace with DOM methods:
   ```javascript
   // Before: element.innerHTML = `<div>${userData}</div>`;
   // After:
   const div = document.createElement('div');
   div.textContent = userData;
   element.appendChild(div);
   ```

#### 1.4 GitHub Actions Permissions (`.github/workflows/security-audit.yml`)
1. Add permissions block at workflow level:
   ```yaml
   permissions:
     contents: read
   ```

**Verification:**
- [ ] `pytest backend/tests/` passes
- [ ] No JavaScript errors in browser console
- [ ] Auth redirect flow still works (login → redirect back to page)
- [ ] GitHub Actions workflow syntax valid

---

### Stage 2: Error Handling - Medium Risk
**Goal:** Prevent stack trace exposure in production by centralizing error handling
**Estimated Time:** ~1 hour

**Files to Create:**
- `backend/utils/error_utils.py`

**Files to Modify:**
- `backend/views/learn_api.py` (lines 253, 680, 772, 814)
- `backend/views/sourcefile_api.py` (lines 805, 920)
- `backend/views/lemma_api.py` (lines 192, 195, 414, 463)
- `backend/views/sentence_api.py` (lines 246, 249)
- `backend/views/wordform_api.py` (line 157)
- `backend/views/profile_api.py` (lines 108, 162)

**Steps:**

#### 2.1 Create Error Utility Module
Create `backend/utils/error_utils.py`:
```python
"""
Error handling utilities for safe error responses.
"""
from flask import current_app, jsonify
from loguru import logger


def safe_error_message(error: Exception, context: str = "") -> str:
    """
    Return a safe error message based on environment.
    
    In production: Returns generic message, logs full error
    In development: Returns full error details
    
    Args:
        error: The exception that occurred
        context: Optional context string for logging
        
    Returns:
        Safe error message string
    """
    is_production = current_app.config.get("IS_PRODUCTION", True)
    
    # Always log the full error
    log_message = f"{context}: {error}" if context else str(error)
    logger.error(log_message)
    
    if is_production:
        return "An internal error occurred. Please try again later."
    else:
        return str(error)


def error_response(error: Exception, status_code: int = 500, context: str = ""):
    """
    Create a JSON error response with safe error message.
    
    Args:
        error: The exception that occurred
        status_code: HTTP status code (default 500)
        context: Optional context string for logging
        
    Returns:
        Flask JSON response tuple (response, status_code)
    """
    message = safe_error_message(error, context)
    return jsonify({"error": message}), status_code
```

#### 2.2 Refactor learn_api.py
Update exception handlers at lines 253, 680, 772, 814:
```python
from backend.utils.error_utils import error_response

# Before:
except Exception as e:
    return jsonify({"error": str(e)}), 500

# After:
except Exception as e:
    return error_response(e, context="learn_api endpoint_name")
```

#### 2.3 Refactor sourcefile_api.py
Update exception handlers at lines 805, 920 using same pattern.

#### 2.4 Refactor lemma_api.py
Update exception handlers at lines 192, 195, 414, 463 using same pattern.

#### 2.5 Refactor sentence_api.py
Update exception handlers at lines 246, 249 using same pattern.

#### 2.6 Refactor wordform_api.py
Update exception handler at line 157 using same pattern.

#### 2.7 Refactor profile_api.py
Update exception handlers at lines 108, 162 using same pattern.

**Verification:**
- [ ] `pytest backend/tests/` passes
- [ ] Test error handling in development (should show full error)
- [ ] Verify no test assertions depend on specific error message text
- [ ] Manual test: trigger an error and verify safe message in production mode

---

### Stage 3: SSRF Protection - High Value
**Goal:** Prevent Server-Side Request Forgery attacks in URL fetching functionality
**Estimated Time:** ~1 hour

**Files to Create:**
- `backend/utils/url_utils.py`

**Files to Modify:**
- `backend/views/sourcefile_api.py` (around line 1033)

**Steps:**

#### 3.1 Create URL Validation Utility
Create `backend/utils/url_utils.py`:
```python
"""
URL validation utilities for SSRF protection.
"""
import ipaddress
import socket
from urllib.parse import urlparse
from loguru import logger


class SSRFValidationError(Exception):
    """Raised when URL fails SSRF validation."""
    pass


def is_private_ip(ip_str: str) -> bool:
    """
    Check if an IP address is private, loopback, or reserved.
    
    Args:
        ip_str: IP address string
        
    Returns:
        True if IP is private/reserved, False otherwise
    """
    try:
        ip = ipaddress.ip_address(ip_str)
        return (
            ip.is_private or
            ip.is_loopback or
            ip.is_reserved or
            ip.is_link_local or
            ip.is_multicast
        )
    except ValueError:
        # Invalid IP format
        return True  # Treat invalid as unsafe


def validate_url_for_ssrf(url: str) -> str:
    """
    Validate a URL for SSRF vulnerabilities.
    
    Checks:
    - Scheme is http or https only
    - Host is not localhost or private IP
    - Host doesn't resolve to private IP
    
    Args:
        url: The URL to validate
        
    Returns:
        The validated URL if safe
        
    Raises:
        SSRFValidationError: If URL fails validation
    """
    if not url:
        raise SSRFValidationError("URL is required")
    
    # Parse URL
    try:
        parsed = urlparse(url)
    except Exception as e:
        raise SSRFValidationError(f"Invalid URL format: {e}")
    
    # Check scheme
    if parsed.scheme not in ('http', 'https'):
        raise SSRFValidationError(f"Invalid scheme: {parsed.scheme}. Only http/https allowed.")
    
    # Check for localhost variants
    hostname = parsed.hostname or ''
    localhost_variants = {
        'localhost', '127.0.0.1', '::1', '0.0.0.0',
        'localhost.localdomain', '127.0.0.0'
    }
    if hostname.lower() in localhost_variants:
        raise SSRFValidationError("Localhost URLs are not allowed")
    
    # Check if hostname looks like an IP
    try:
        if is_private_ip(hostname):
            raise SSRFValidationError("Private IP addresses are not allowed")
    except ValueError:
        pass  # Not an IP, continue with DNS resolution
    
    # Resolve hostname and check resulting IP
    try:
        resolved_ips = socket.getaddrinfo(hostname, parsed.port or 80)
        for family, type_, proto, canonname, sockaddr in resolved_ips:
            ip = sockaddr[0]
            if is_private_ip(ip):
                logger.warning(f"SSRF blocked: {hostname} resolves to private IP {ip}")
                raise SSRFValidationError("URL resolves to private IP address")
    except socket.gaierror as e:
        raise SSRFValidationError(f"Could not resolve hostname: {hostname}")
    except SSRFValidationError:
        raise
    except Exception as e:
        logger.error(f"SSRF validation error for {url}: {e}")
        raise SSRFValidationError(f"URL validation failed: {e}")
    
    return url
```

#### 3.2 Apply SSRF Validation to sourcefile_api.py
Update `create_sourcefile_from_url_api` endpoint (around line 1033):
```python
from backend.utils.url_utils import validate_url_for_ssrf, SSRFValidationError

# In the endpoint, before making the request:
try:
    validated_url = validate_url_for_ssrf(url)
except SSRFValidationError as e:
    return jsonify({"error": str(e)}), 400

# Use validated_url for the request
```

**Verification:**
- [ ] `pytest backend/tests/` passes
- [ ] Test: Attempt to fetch `http://localhost/` → should fail
- [ ] Test: Attempt to fetch `http://192.168.1.1/` → should fail
- [ ] Test: Attempt to fetch `http://10.0.0.1/` → should fail
- [ ] Test: Fetch valid external URL → should succeed
- [ ] Test: Fetch URL that DNS-rebinds to private IP → should fail

---

### Stage 4: Cleanup - Low Priority
**Goal:** Remove obsolete code to reduce attack surface and eliminate Dependabot noise
**Estimated Time:** ~15 minutes

**Files/Directories to Delete:**
- `backend/old_frontend/` (entire directory)

**Steps:**

#### 4.1 Verify No Dependencies on old_frontend
1. Search for imports referencing old_frontend:
   ```bash
   rg "old_frontend" --type py
   rg "old_frontend" --type js
   ```
2. Verify vercel.json excludes it (confirmed)
3. Check no symbolic links point to it

#### 4.2 Delete the Directory
```bash
rm -rf backend/old_frontend/
```

#### 4.3 Verify Git History Preserved
The directory contents remain accessible in git history for reference if needed.

**Verification:**
- [ ] `pytest backend/tests/` passes
- [ ] Application loads without errors
- [ ] `rg "old_frontend"` returns no results (except possibly in docs)
- [ ] Git commit preserves the deletion history

---

## Commit Strategy

Per `gjdutils/docs/instructions/GIT_COMMIT_CHANGES.md`:

| Commit | Scope | Message |
|--------|-------|---------|
| 1 | Stage 1 | `fix(security): add open redirect validation, DOM XSS fixes, GH Actions perms` |
| 2 | Stage 2 | `fix(security): centralize error handling to prevent stack trace exposure` |
| 3 | Stage 3 | `fix(security): add SSRF protection for URL fetching` |
| 4 | Stage 4 | `chore: remove obsolete backend/old_frontend directory` |

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking auth redirect flow | Low | High | Fall back to `/` for any invalid redirect URL |
| Tests fail due to changed error messages | Medium | Low | Update test assertions if needed; most tests check status codes not messages |
| SSRF validation too strict | Medium | Medium | Log rejected URLs for debugging; allow standard schemes |
| old_frontend deletion loses needed code | Low | Low | Git history preserves all deleted files |
| DNS rebinding attacks bypass SSRF | Low | Medium | Validate resolved IPs, not just hostnames |

---

## Existing Patterns to Follow

| Pattern | Location | Usage |
|---------|----------|-------|
| Error logging | Throughout views | `current_app.logger.error()` or `logger.error()` |
| Production check | Config | `current_app.config.get("IS_PRODUCTION", True)` |
| Logging import | Views | `from loguru import logger` |
| Flask error response | Views | `return jsonify({"error": "message"}), status_code` |

---

## Implementation Notes

<!-- Updated by implementer as stages complete -->

### Stage 1 Notes
- Decisions made:
- Learnings:
- Deviations from plan:

### Stage 2 Notes
- Decisions made:
- Learnings:
- Deviations from plan:

### Stage 3 Notes
- Decisions made:
- Learnings:
- Deviations from plan:

### Stage 4 Notes
- Decisions made:
- Learnings:
- Deviations from plan:

---

## Appendix: Unaddressed Issues

Issues identified during triple review that were not addressed in this implementation:

### 1. Auth Redirect Parameter Mismatch (Pre-existing)
- **Location:** `backend/utils/auth_utils.py` vs `backend/views/auth_views.py`
- **Issue:** `page_auth_required` decorator redirects to `/auth?next=...` but `auth_page_vw()` reads `request.args.get("redirect")`, not `next`. This causes the return-to-original-page flow to potentially fail.
- **Why not fixed:** Pre-existing inconsistency, not introduced by security fixes. Requires coordinated changes across templates and potentially frontend code.
- **Recommendation:** Standardize on a single parameter name (likely `redirect`) and URL-encode the value.

### 2. SSRF: IPv4-mapped IPv6 Addresses
- **Location:** `backend/utils/url_utils.py`
- **Issue:** Theoretical bypass using IPv4-mapped IPv6 addresses like `::ffff:127.0.0.1` which may not be classified as loopback in all Python versions.
- **Why not fixed:** Low likelihood; Python's `ipaddress` module handles most cases. Would require additional complexity.
- **Recommendation:** For stricter validation, use `if not ip.is_global: block` or special-case IPv4-mapped IPv6.

### 3. SSRF: DNS Rebinding (TOCTOU)
- **Location:** `backend/utils/url_utils.py`, `backend/views/sourcefile_api.py`
- **Issue:** Time-of-check-time-of-use race condition where DNS could return different IP between validation and `requests.get()`.
- **Why not fixed:** Requires more complex implementation (custom transport adapter or request with resolved IP).
- **Recommendation:** For critical security, implement request pinning to validated IP.

### 4. Double Stack Trace Logging
- **Location:** Multiple API files
- **Issue:** Some endpoints call `logger.exception()` before `safe_error_message()`, which also logs. Results in duplicate stack traces.
- **Why not fixed:** Minor noise issue, not a security concern. Would require auditing all existing logging calls.
- **Recommendation:** Decide on single logging location (either caller or `safe_error_message`).

### 5. safe_error_message Used for 4xx Responses
- **Location:** `backend/views/languages_api.py` and others
- **Issue:** Using `safe_error_message()` for 404s returns "An internal error occurred" in production, which is misleading for "not found" errors.
- **Why not fixed:** Would require distinguishing between expected errors (4xx) and unexpected errors (5xx) throughout codebase.
- **Recommendation:** Use `safe_error_message()` only for 5xx; return specific non-sensitive messages for 4xx.
